#include <iostream>

#include <thread>
#include <future>
#include <functional>
#include <memory>

#include "observable.hpp"

template<typename ... A>
using F = std::function<void(A ...)>;

template<typename ... A>
using Fptr = void(*)(A ...);

void cb(int value)
{
    std::cout << "modification = " << value << std::endl;
}

void cb()
{
}

template<typename T>
struct ref_specialization;

template<typename T>
struct ref_specialization
{
    T value;
};

template<typename T>
struct ref_specialization<T &>
{
    std::reference_wrapper<T> reference;
};

int main()
{
    // specialization for reference types
    if (false)
    {
        auto value = 0;
        auto sp_value = std::make_shared<int>(0);

        auto rsv = ref_specialization<int>{value};
        auto rsr = ref_specialization<int &>{*sp_value};
    }

    // basic observable (single type)
    if (false)
    {
        basic_obe<F, int> o{12};

        auto observer = [](int value)
        {
            std::cout << value << std::endl;
        };

        auto g = o.observe(observer);
        o.notify();
        o.get() = 7;
        o.notify();
        o.get() = 3;
        o.notify();
    }

    // basic observable (overloading)
    if (false)
    {
        // free function
        {
            basic_obe<Fptr, int> o;

            auto g = o.observe(cb);     // automatically takes the correct function
            o.notify();
            o.get() = 4;
            o.notify();
        }

        // std::function
        {
            basic_obe<F, int> o;
            o.observe<void(*)(int)>(cb);
        }
    }

    // unique observable
    if (false)
    {
        unique_obe o{4};

        auto observer = [](int i)
        {
            std::cout << i << std::endl;
        };

        o.observe(observer);
        o.notify();
        o = 12;
        o.notify();

        auto o_moved = std::move(o);
        o.notify();
        o_moved.notify();

        o_moved.observe(observer);
        o_moved.notify();
        o.observe(observer);
        o.notify();
    }

    // unique and shared transactions
    if (false)
    {
        shared_obe o{0};

        auto observer = [](int i)
        {
            std::cout << i << std::endl;
        };
        o.observe(observer);

        auto proc = [o]() mutable
        {
            for (auto n = 0; n != 10; ++n)
            {
                unique_txn ug{o};
                ug = 0;
            }
        };
        std::thread t(std::move(proc));

        {
            unique_txn ug(o);
            ug = 4;
            ug = 15;
            ug = 1;
            // yields only a single notify
        }

        std::this_thread::sleep_for(std::chrono::seconds(1));

        {
            unique_txn ug(o);
            ug = 7;
        }

        {
            // access from two shared transactions
            shared_txn sg(o);
            std::cout << sg.get() << std::endl;
            std::cout << shared_txn{o}.get() << std::endl;
        }

        t.join();
    }

    // join shared observables
    if (false)
    {
        shared_obe<int> a;
        shared_obe<int> b;

        auto c = join(a, b);

        auto observer = [](std::tuple<int, int> value)
        {
            std::cout << std::get<0>(value) << ", " << std::get<1>(value)<< std::endl;
        };
        c.observe(observer);

        unique_txn{a} = 7;
        unique_txn{b} = 4;
        unique_txn{c} = std::tuple{4, 8};
    }

    // compose shared observables
    if (false)
    {
        shared_obe<int> a;
        shared_obe<int> b;
        shared_obe<int> sum;

        auto observer_ab = [sum](int value_a, int value_b) mutable
        {
            unique_txn{sum} = value_a + value_b;
        };
        join(observer_ab, a, b);

        auto observer_sum = [](int value_c)
        {
            std::cout << value_c << std::endl;
        };
        sum.observe(observer_sum);

        unique_txn{a} = 7;
        unique_txn{b} = 4;
    }

    // join 2 shared observables (no composite)
    if (false)
    {
        shared_obe<int> a;
        shared_obe<int> b;

        auto observer = [](int value_a, int value_b)
        {
            std::cout << value_a << ", " << value_b << std::endl;
        };
        join(observer, a, b);

        unique_txn{b} = 4;
        unique_txn{a} = 7;
    }

    // join 3 shared observables (no composite)
    if (false)
    {
        shared_obe<int> a;
        shared_obe<int> b;
        shared_obe<int> c;

        auto observer = [](int value_a, int value_b, int value_c)
        {
            std::cout << value_a << ", " << value_b << ", " << value_c << std::endl;
        };
        join(observer, a, b, c);

        unique_txn{b} = 4;
        unique_txn{a} = 7;
        unique_txn{c} = 1;
        unique_txn{a} = 8;
    }

    // await_if shared observable
    if (false)
    {
        shared_obe<int> a;

        auto proc = [a]() mutable
        {
            std::this_thread::sleep_for(std::chrono::seconds(1));
            unique_txn{a} = 4;
            std::this_thread::sleep_for(std::chrono::seconds(1));
            unique_txn{a} = 16;
        };
        std::thread t(proc);

        auto pred = [](int n)
        {
            return n == 16;
        };

        std::cout << "awaiting value" << std::endl;
        auto txn = await_if(a, pred);
        std::cout << txn.get() << std::endl;

        t.join();
    }

    // await_any shared observable
    if (true)
    {
        shared_obe<std::tuple<int, int>> a;

        auto proc = [a]() mutable
        {
            std::this_thread::sleep_for(std::chrono::seconds(1));
            unique_txn{a} = {4, 2};
            std::this_thread::sleep_for(std::chrono::seconds(1));
            unique_txn{a} = {16, 2};
        };
        std::thread t(proc);

        {
            std::cout << "awaiting any change" << std::endl;
            auto txn = await_any(a);
            std::cout << std::get<0>(txn.get()) << ", " << std::get<1>(txn.get()) << std::endl;
        }

        t.join();
    }

    // await shared observable
    if (false)
    {
        shared_obe<std::tuple<int, int>> a;

        auto proc = [a]() mutable
        {
            std::this_thread::sleep_for(std::chrono::seconds(1));
            unique_txn{a} = {4, 2};
            std::this_thread::sleep_for(std::chrono::seconds(1));
            unique_txn{a} = {16, 8};
            std::this_thread::sleep_for(std::chrono::seconds(1));
            unique_txn{a} = {16, 2};
        };
        std::thread t(proc);

        std::cout << "awaiting value" << std::endl;
        await(a, std::tuple{16, 2});
        const auto v = shared_txn{a}.get();
        std::cout << std::get<0>(v) << ", " << std::get<1>(v) << std::endl;

        t.join();
    }

    // shared observable without value (a shared signal)
    if (false)
    {
        shared_obe<void> so;

        auto observer = []
        {
            std::cout << "observer notified" << std::endl;
        };
        so.observe(observer);

        so.notify();

        auto proc = [so]
        {
            std::cout << "observer in thread notified" << std::endl;
        };
        std::thread t(proc);
        so.notify();
        t.join();
        so.notify();
    }

    /*
    // shared observarble of reference
    if (false)
    {
        shared_obe<std::unique_ptr<int>> o;
        
        auto observer = [](const int & ref)
        {
            std::cout << ref << std::endl;
        };
        o.observe(observer);
        o.m_sp->notify();
        *o.m_sp->get() = 5;
        o.m_sp->notify();
    }
<<<<<<< HEAD

    // tunnel value from one observable to another
    if (true)
    {
        shared_observable<int> soA;
        shared_observable<int> soB;

        auto observer_a = [](int value)
        {
            std::cout << "A changed = " << value << "\n";
        };

        auto observer_b = [](int value)
        {
            std::cout << "B changed = " << value << "\n";
        };

        soA.observe(observer_a);
        soB.observe(observer_b);

        unique_txn{soA} = 7;
        connect(soA, soB);
        unique_txn{soA} = 42;
    }
=======
    */
>>>>>>> c35a7d1134e2728cf9e749a2a27d0b89abca2519
}